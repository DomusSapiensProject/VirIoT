"""
Module to communicate with devices through the ChirpStack MQTT broker
"""

import logging
from base64 import b64encode
import json

import paho.mqtt.client as mqtt


log = logging.getLogger(__name__)


class AppController :
    """
    Abstraction of the Chirsptack Application.
    Makes the link between the devices and the broker
    """
    def __init__(self,appId, mqtt_broker):
        """
        Parameters:
        - appId : application ID in Chirpstack
        - mqtt_broker : a running instance of egm.mqtt.MqttBroker
        """
        self.appId = appId
        self.broker = mqtt_broker
        self.devices = []

    def register_device(self, device_controller):
        self.devices.append(device_controller)
        log.info(f"Initializing device communications")
        for topic,callback in device_controller.get_callbacks():
            self.broker.subscribe(topic,callback)
        
    def send(self, topic, payload):       
        self.broker.publish(topic, payload)
       

class DeviceController:
    def __init__(self, deveui, app):
        self.deveui = deveui
        self.app = app
        app.register_device(self)

    def define_topics(self):
        """
        Compute the topics to be subscribed to on Chirpstack MQTT broker. 
        The "decoded" topic is not directly generated by Chirpstack. It is to give the developper the possibility to
        implement the decoding of the incoming message on the Chirpstack broker. It should then publish the result
        on this topic.
        """
        self.topic_base = f"application/{self.app.appId}/device/{self.deveui}"
        self.topic_uplink_decoded = f"{self.topic_base}/decoded"
        self.topic_uplink_raw = f"{self.topic_base}/rx"
        self.topic_status = f"{self.topic_base}/status"
        self.topic_ack = f"{self.topic_base}/ack"
        self.topic_error = f"{self.topic_base}/error"
        self.topic_downlink = f"{self.topic_base}/tx"
        self.log_header = f"DEVICE:{self.app.appId}:{self.deveui}"
        
    def get_callbacks(self):
        """
        Called by ApplicationController to get the mapping event/callback during device registration.
        """
        self.define_topics()
        return [
            (self.topic_uplink_raw, self.on_uplink_raw),
            (self.topic_uplink_decoded, self.on_uplink_decoded),
            (self.topic_status, self.on_status),
            (self.topic_ack, self.on_ack),
            (self.topic_error, self.on_error)
        ]
        
    def on_uplink_raw(self, msg):
        """
        Uplink (raw data) event. Overload in subclasses if needed.
        """
        log.debug(f"{self.log_header}:MQTT UPLINK RAW:{msg.topic}:{msg.payload}")

    def on_uplink_decoded(self, msg):
        """
        Uplink (decoded data) event. Overload in subclasses if needed.
        """
        log.debug(f"{self.log_header}:MQTT UPLINK DEC:{msg.topic}:{msg.payload}")

    def on_status(self, msg):
        """
        Status event. Overload in subclasses if needed.
        """
        log.debug(f"{self.log_header}:MQTT STATUS:{msg}")

    def on_ack(self, msg):
        """
        Ack event. Overload in subclasses if needed.
        """
        log.debug(f"{self.log_header}:MQTT ACK:{msg}")

    def on_error(self, msg):
        """
        Error event. Overload in subclasses if needed.
        """
        log.debug(f"{self.log_header}:MQTT ERROR:{msg}")

    def do_downlink(self, message):
        """
        Request downlink for the device.
        - Prepare the MQTT payload such that the device receives the provided message.
        - Send the message to the broker
        """
        payload = json.dumps({
            "confirmed": True,        
            "fPort": 10,              
            "data": b64encode(message.encode()).decode()
        })
        log.debug(f"{self.log_header}:sending:{payload}")
        self.app.send(self.topic_downlink, payload)
